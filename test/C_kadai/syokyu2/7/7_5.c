/*
8 [共通課題] N竜の配置

【氏名】      田村　寛忠
【学籍番号】  201IR077P
【作成日】    2021年8月15日

【仕様／目的】
    コマンドライン入力から正整数 N（4≦N≦11） が与えられたとき、N×
    Nの将棋盤上にN個の竜を互いに「効き」が無いように配置する仕方が何通り可能であるかを求めて、
    標準出力にその値を必要最小限の桁数で１行に書き出すプログラム

【入力】
    ・コマンドライン入力から正整数  N（4≦N≦11）が与えられる。
    ・データの列は、つぎの2つの関数を使って得る。

【出力】
    ・2度以上現れる文字列が存在しなければ、何も出力しないで実行を終了する。
    ・2度以上現れる文字列が存在していれば、現れた回数が最も大きな文字列の出現回数 m を求め、
    　かつ、その出現回数をもつ文字列が何種類存在したかを、
    　つぎの形の１行として標準出力に書き出す。
        m(k)・・・m 出現回数の最大値
                　k その最大回数出現した文字列の種類数
    ・二つの数値 m、k は必要最小限の桁数で書き出す

【構成／アルゴリズム】



【機能保障】


【関数】
     void solve(int x){
     説明   ：
     引数   ：int型
     戻り値 ：なし
     
【参考サイト】
    https://daeudaeu.com/nqueen/
*/


#include <stdio.h>
#include <string.h>
#define MAXN 40 // 単語数の最大値
#define LEN 10 // 単語長の最大値
int n; // 単語数
int len[MAXN]; // 単語の長さを覚える配列
char word[LEN+1]; // 単語を読み込む配列
// pos 番目以降の単語列で短句が構成出来るかどうかをチェック
int is_ok(int pos)
{
 int rest;
 rest = 5; // 最初の区切りの長さは５
 while(rest > 0){
 rest -= len[pos++]; // 必要な文字数から単語の文字数を引く
 if(rest < 0) return 0; // 負になったらダメ
 }
 rest = 7; // ２番目の区切りの長さは７
 while(rest > 0){
 rest -= len[pos++]; // 必要な文字数から単語の文字数を引く
 if(rest < 0) return 0; // 負になったらダメ
 }
 rest = 5; // ３番目の区切りの長さは５
 while(rest > 0){
 rest -= len[pos++]; // 必要な文字数から単語の文字数を引く
 if(rest < 0) return 0; // 負になったらダメ
 }
 rest = 7; // ４番目の区切りの長さは７
 while(rest > 0){
 rest -= len[pos++]; // 必要な文字数から単語の文字数を引く
 if(rest < 0) return 0; // 負になったらダメ
 }
 rest = 7; // ５番目の区切りの長さは７
 while(rest > 0){
 rest -= len[pos++]; // 必要な文字数から単語の文字数を引く
 if(rest < 0) return 0; // 負になったらダメ
 }
 return 1; // 短句になっている
}
int main(void)
{
 for(;;){
 int i;
 scanf("%d\n", &n); // 単語数 n を入力
 if(n==0) break; // n==0 なら終了
 for(i=0; i<n; i++){ // 単語を n 個読み込んでその長さを格納
 scanf("%s\n", word); // 単語を読み込む
 len[i] = strlen(word); // その長さを格納
 }
 for(i=0; i<n; i++){ // 先頭の単語から順に
 if(is_ok(i)){ // その単語から始めて短句を構成できるかをチェック
printf("%d\n", i+1); // 構成出来る場合はその単語位置をプリント
break;
 }
 }
 }
}

