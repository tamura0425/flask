/*
 [選択課題] ディリクレの算術級数定理 (ICPC)

【氏名】      田村　寛忠
【学籍番号】  201IR077P
【作成日】    2021年8月15日

【仕様／目的】
    コマンドライン入力から正整数 N（4≦N≦11） が与えられたとき、N×
    Nの将棋盤上にN個の竜を互いに「効き」が無いように配置する仕方が何通り可能であるかを求めて、
    標準出力にその値を必要最小限の桁数で１行に書き出すプログラム

【入力】
入力はデータセットの並びである． データセットは，1文字の空白で区切られた三つの正整数 a と d と n とからなる行である．a と d は互いに素である． a ≦ 9307 かつ d ≦ 346 かつ n ≦ 210 と仮定してよい．



入力の終わりは，1文字の空白で区切られた三つのゼロからなる行で示される．これはデータセットではない．

【出力】

出力は入力データセットと同数の行で構成されなければならない． 各行は一つの整数を含まなければならない．余計な文字を含めてはならない．



データセット a, d, n に対応する出力の整数は，a から始まり d ずつ増える等差数列に含まれる素数のうちで n 番目のものでなくてはならない．
なお，この入力条件の下で，結果は必ず 106 (百万)より小さいことがわかっている．

【構成／アルゴリズム】
素数を扱う問題では、主にふたつの素数データを用いる。ひとつが素数表であり、もうひとつが
素数配列である。
素数表とは、素数であるかどうかを True or False で判定できるようにしたものである。すな
わち、
Prime_table[2] = true ;
Prime_table[3] = true ;
Prime_table[4] = false;
・・・
といったようになる。これを用いれば、Prime_table[i]とするだけで、i が素数かどうかを判別
できるため、ある数が素数かどうかを知りたいときに役立つ。
これに対し、素数配列とは、素数を小さい順に格納した配列である。すなわち、
Prime[0] = 2;
Prime[1] = 3;
Prime[2] = 5;
Prime[3] = 7;
・・・
といったようになる。これは、素数そのものが必要になるときに利用すると便利である。
素数表を実現するアルゴリズムがエラトステネスの篩である。アルゴリズムの正当性については
説明を割愛するが、これは、
28
1.Prime_table[0]と [1] を除き、すべて Prime_table[i] = true とする。
2.i = 0 から始めて、Prime_table[i]が true になるまで、i を増やしていく。
3.Prime_table[i] = true になったら、その i の倍数をすべて false にしていく。
　　すなわち、
Prime_table[2*i] = false;
Prime_tabel[3*i] = false;
　　・・・
4. 求めたい上限の値の平方根まで、2.～3. を繰り返し続ける。
というものである。
素数配列については、この素数表を用いることで作成できる。すなわち、
count = 0;
for(i=0;i<MAX;i++){
if(Prime_tabel[i] == true){
Prime[count] = i;
count++;
}
}



【機能保障】


【関数】
     void solve(int x){
     説明   ：
     引数   ：int型
     戻り値 ：なし
     
【参考サイト】
    https://daeudaeu.com/nqueen/
*/


#include<stdio.h>
#define MAX 1000000
int main(void){
    int i,c;
    int a,d,n;
    char p[MAX];
    p[0]=0;
    p[1]=0; //1 は素数でない
    p[2]=1; //2 は素数である
    for(i=3;i<MAX;i+=2)p[i]=1; //奇数は素数の可能性がある
    for(i=4;i<MAX;i+=2)p[i]=0; //偶数は素数の可能性がない
    c = 3;
    
    while(1){
        for(i=2*c;i<MAX;i+=c){
            p[i] = 0; //自身の倍数の check をはずす
        }
        //次の素数まで進める   
        while(!p[++c]){
            
        }
        if(c>1000){
            break; //MAX の２乗根まで調べれば充分
        }
    }
    
    while(1){
    scanf("%d %d %d ",&a,&d,&n);
    if(!a && !d && !n)break;
    c = 0;
    i = 0;
        while(1){
            if(p[a+i*d]){
                c++; //a+i*dが素数であれば、カウントを増やして個数を数え上げ
            }
            if(n==c){ //個数が n と一致すれば
                printf("%d\n",a+i*d); //その値を出力
                break;
            }
            i++;
        }
    }
    return 0;
}

