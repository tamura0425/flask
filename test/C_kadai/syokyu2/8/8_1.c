/*
8 [共通課題] N竜の配置

【氏名】      田村　寛忠
【学籍番号】  201IR077P
【作成日】    2021年8月8日

【仕様／目的】
    コマンドライン入力から正整数 N（4≦N≦11） が与えられたとき、N×
    Nの将棋盤上にN個の竜を互いに「効き」が無いように配置する仕方が何通り可能であるかを求めて、
    標準出力にその値を必要最小限の桁数で１行に書き出すプログラム

【入力】
    ・コマンドライン入力から正整数  N（4≦N≦11）が与えられる。
    ・データの列は、つぎの2つの関数を使って得る。

【出力】
    ・2度以上現れる文字列が存在しなければ、何も出力しないで実行を終了する。
    ・2度以上現れる文字列が存在していれば、現れた回数が最も大きな文字列の出現回数 m を求め、
    　かつ、その出現回数をもつ文字列が何種類存在したかを、
    　つぎの形の１行として標準出力に書き出す。
        m(k)・・・m 出現回数の最大値
                　k その最大回数出現した文字列の種類数
    ・二つの数値 m、k は必要最小限の桁数で書き出す

【構成／アルゴリズム】



【機能保障】


【関数】
     void solve(int x){
     説明   ：
     引数   ：int型
     戻り値 ：なし
     
【参考サイト】
    https://daeudaeu.com/nqueen/
*/

#include  <stdio.h> 
#include  <stdlib.h>

//---------------------------------------------------------------- 
#define  N 20 
#define  LR(x,y) (x-y+N-1)  
#define  RL(x,y) (x+y)
char board[N][N];
int lr[2*N-1];
int rl[2*N-1];
int h[N];
int count;
int n;

void solve(int x){
 int y;            //行
 if( x==n ){           //全列配置し終わったら
   count++; //show();  //カウントひとつ増やす
   return;             //ループを抜ける
 }
 for(y= 0; y!=n; y++){     //全行終わるまで
 
   if( !h[y] && !lr[LR(x,y)] && !rl[RL(x,y)] ){
     h[y]= lr[LR(x,y)]= rl[RL(x,y)]= 1;    //配置判定済
     board[x][y]= 'Q';     //王妃を配置
     solve(x+1);           //再帰的に次の列を判定
     
     board[x][y]= '.';     //盤面の初期化
     h[y]= lr[LR(x,y)]= rl[RL(x,y)]= 0;    //配置判定初期化
   }
 }
}


//----------------------------------------------------------------
int main(int argc, char *argv[]){
 
 int x, y;
 n= atoi(argv[1]); //コマンドラインより数値を取得
 
 for(y= 0; y!=n; y++){     //盤面の初期化
   h[y]= 0;                //行未配置設定
   for(x= 0; x!=n; x++){   //列初期化
     board[x][y]= '.';     //未配置
     lr[LR(x,y)]= 0;       //斜めライン配置判定初期化
     rl[RL(x,y)]= 0;       //斜めライン配置判定初期化
   }
 }
 count= 0;         //カウンタ初期化
 solve(0);         //関数solveて配置判定
 
 printf("%d\n", count);        //結果出力

 return 0;
} 
