/*
8 [共通課題] N竜の配置

【氏名】      田村　寛忠
【学籍番号】  201IR077P
【作成日】    2021年8月8日

【仕様／目的】
    コマンドライン入力から正整数 N（4≦N≦11） が与えられたとき、N×
    Nの将棋盤上にN個の竜を互いに「効き」が無いように配置する仕方が何通り可能であるかを求めて、
    標準出力にその値を必要最小限の桁数で１行に書き出すプログラム

【入力】
    ・コマンドライン入力から正整数  N（4≦N≦11）が与えられる。
    ・データの列は、つぎの2つの関数を使って得る。

【出力】
    ・2度以上現れる文字列が存在しなければ、何も出力しないで実行を終了する。
    ・2度以上現れる文字列が存在していれば、現れた回数が最も大きな文字列の出現回数 m を求め、
    　かつ、その出現回数をもつ文字列が何種類存在したかを、
    　つぎの形の１行として標準出力に書き出す。
        m(k)・・・m 出現回数の最大値
                　k その最大回数出現した文字列の種類数
    ・二つの数値 m、k は必要最小限の桁数で書き出す

【構成／アルゴリズム】



【機能保障】


【関数】
     void solve(int x){
     説明   ：
     引数   ：int型
     戻り値 ：なし
     
【参考サイト】
    https://daeudaeu.com/nqueen/
*/

#include  <stdio.h> 
#include  <stdlib.h>

//------------------------------------------------ 
#define  N 12    //盤面
int brd[N][N];  //12*12
int flg[N];     //配置済み
int ct;         //全駒配置できた回数
int n;    //x：列、n：個数

//------------------------------------------------
void solve(int x){
	int y;          //y：行
	if(x == n+1){     //xがnになったら
       ct++;       //カウント
       return;     //ループを抜ける
   }
	for(y=0; y<n; y++){     //行がnになるまで
		if(!flg[y] && !brd[x-1][y-1] && !brd[x-1][y+1]){    //配置済みでないなら
		    flg[y]= 1;              //配置済み判定
		    brd[x][y]= 1;           //配置
		    solve(x + 1);           //次の列へ
		    brd[x][y] = 0;          //未配置
	    	flg[y] = 0;             //未配置判定
	    }
   }
}

//------------------------------------------------
int main(int argc, char *argv[]){

	int i, j;           //ループカウンタ
	n= atoi(argv[1]);   //コマンドラインより数値取得
	
	for(i=0; i<n; i++){     //配置判定と盤面の初期化
	    flg[i]= 0;
	    for(j=0; j<n; j++){
	        brd[i][j]= 0;
	    }
	}

	ct= 0;      //カウンタ初期化
	solve(1);   //solve関数で配置判定
	printf("%d\n",ct);      //結果出力
	
return 0;
}



